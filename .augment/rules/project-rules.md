---
type: "always_apply"
---

# Asspp 项目规则

## 项目概述

**项目名称**: Asspp  
**项目类型**: iOS/macOS 应用程序  
**主要功能**: 无缝多账户 App Store 管理工具  
**技术栈**: Swift, SwiftUI, Vapor, ApplePackage  
**平台支持**: iOS 15+, macOS 12+  
**许可证**: MIT License

### 核心功能模块

1. **多账户管理** - 支持多个 Apple ID 账户管理
2. **应用搜索** - 在 App Store 中搜索应用
3. **应用下载** - 从 App Store 下载应用和历史版本
4. **IPA 安装** - 在非越狱设备上安装 IPA 文件
5. **设备管理** - 通过 DeviceCTL 管理连接的 iOS 设备
6. **文件共享** - 轻松共享 IPA 文件

### 项目架构

```
Asspp/
├── App/              # 应用入口和资源
├── Interface/        # SwiftUI 界面层
│   ├── Account/      # 账户管理界面
│   ├── Search/       # 搜索界面
│   ├── Download/     # 下载管理界面
│   ├── Setting/      # 设置界面
│   └── Welcome/      # 欢迎和主界面
├── Backend/          # 业务逻辑层
│   ├── AppStore/     # App Store 相关逻辑
│   ├── Downloader/   # 下载管理
│   ├── Installer/    # 安装服务(Vapor)
│   └── DeviceCTL/    # 设备控制(仅 macOS)
└── Extension/        # 扩展和工具类

Foundation/
└── ApplePackage/     # Apple 包管理库(独立 Swift Package)
```

---

## 解答问题前提规则

### 1. 上下文理解与需求分析

在开始任何代码修改之前,必须:

- **理解用户意图**: 明确用户想要解决的具体问题或实现的功能
- **分析影响范围**: 确定修改会影响哪些模块(Interface/Backend/Foundation)
- **平台兼容性**: 考虑 iOS 和 macOS 平台的差异,使用条件编译 `#if os(macOS)` / `#if canImport(UIKit)`
- **依赖关系**: 理解 ApplePackage 库与主应用的依赖关系

### 2. 需求理解与复述

在执行任务前:

- **复述需求**: 用简洁的语言向用户确认理解的需求
- **明确边界**: 说明将要修改的文件和模块
- **提出疑问**: 如果需求不明确,主动询问细节
- **平台确认**: 确认修改是针对 iOS、macOS 还是两者

### 3. 代码修改的全局考量

修改代码时必须考虑:

- **架构分层**: 遵循 Interface(UI) -> Backend(逻辑) -> Foundation(基础库) 的分层架构
- **状态管理**: 使用 `@Observable` 宏(优先)或 `ObservableObject` 管理状态
- **并发安全**: 使用 `@MainActor` 标记 UI 相关类和方法
- **错误处理**: 使用 `Result` 类型或 `throws` 进行错误传播
- **内存管理**: 注意闭包中的循环引用,使用 `[weak self]` 或 `[unowned self]`

### 4. 多文件修改的规划与沟通

当修改涉及多个文件时:

- **列出清单**: 明确列出需要修改的所有文件
- **说明原因**: 解释为什么每个文件需要修改
- **修改顺序**: 按照依赖关系从底层到上层修改(Foundation -> Backend -> Interface)
- **增量验证**: 建议在关键步骤后进行测试验证

### 5. 问题整体解决方法论

解决问题的标准流程:

1. **信息收集**: 使用 `codebase-retrieval` 和 `view` 工具收集相关代码
2. **方案设计**: 设计符合项目架构的解决方案
3. **影响分析**: 分析对现有代码的影响
4. **实施修改**: 按照计划执行代码修改
5. **测试建议**: 建议用户编写或运行相关测试

---

## 禁止事项

### 1. 复杂修改的处理规范

**禁止**在未充分理解的情况下进行以下操作:

- 修改 `ApplePackage` 库的核心认证逻辑
- 更改 `Installer` 的 TLS 配置和证书处理
- 修改 `DeviceCTL` 的设备通信协议
- 改变应用的签名和证书机制

### 2. 问题解决的全面性要求

**必须**确保:

- 修改后的代码在 iOS 和 macOS 平台都能正常工作(如适用)
- 更新所有受影响的调用点和依赖
- 保持与 `ApplePackage` 库的 API 兼容性
- 不破坏现有的多账户管理功能

### 3. 可能导致项目风险的操作限制

**严格禁止**未经用户明确同意:

- 修改应用的 Bundle ID 或签名配置
- 更改 Keychain 存储的密钥名称
- 修改网络请求的 SNI 配置(`app.localhost.qaq.wiki`)
- 删除或重命名已发布的公共 API
- 修改 `Info.plist` 中的权限配置

---

## 代码质量保障

### 1. Swift 代码风格(遵循 AGENTS.md)

**缩进与格式**:
- 使用 4 空格缩进
- 左大括号在同一行
- 运算符和逗号周围使用单个空格

**命名规范**:
- 类型使用 PascalCase: `AppStore`, `UserAccount`, `PackageManifest`
- 属性和方法使用 camelCase: `downloadApp()`, `selectedDevice`
- 文件名使用 PascalCase,扩展使用 `+`: `Installer+TLS.swift`

**现代 Swift 特性**:
- 优先使用 `@Observable` 宏替代 `ObservableObject`/`@Published`
- 使用 Swift 并发: `async/await`, `Task`, `actor`, `@MainActor`
- 使用不透明类型: `some View` 用于协议返回
- 使用属性包装器: `@PublishedPersist` 用于持久化状态

**代码结构**:
- 使用提前返回减少嵌套
- 使用 `guard` 语句进行可选值解包
- 单一职责原则,每个类型/扩展只负责一个功能
- 优先使用值类型(struct)而非引用类型(class)

**错误处理**:
- 使用 `Result` 枚举处理类型化错误
- 使用 `throws`/`try` 进行错误传播
- 使用 `guard let`/`if let` 进行可选链
- 定义明确的错误类型

**架构模式**:
- 面向协议设计
- 依赖注入优于单例
- 组合优于继承
- 使用工厂/仓储模式

**调试断言**:
- 使用 `assert()` 进行开发时不变量检查
- 使用 `assertionFailure()` 标记不可达代码路径
- 使用 `precondition()` 进行致命错误检查

**内存管理**:
- 使用 `weak` 引用避免循环引用
- 使用 `unowned` 当保证非 nil 时
- 在闭包中使用捕获列表
- 在 `deinit` 中进行清理

### 2. 性能优化规则

- **异步操作**: 所有网络请求和文件 I/O 必须使用 `async/await`
- **主线程**: UI 更新必须在主线程,使用 `@MainActor` 或 `DispatchQueue.main.async`
- **资源管理**: 及时释放大文件和网络连接,使用 `defer` 确保清理
- **缓存策略**: 合理使用 `@PublishedPersist` 进行状态持久化

### 3. 安全性与兼容性

- **Keychain 存储**: 敏感信息(账户、设备标识)必须存储在 Keychain
- **证书验证**: 保持 TLS 证书的正确配置和验证
- **版本兼容**: 使用 `@available` 检查 API 可用性
- **平台隔离**: 使用条件编译隔离平台特定代码

---

## 问题解决与代码优化

### 1. 问题解决阶段优先级

**优先级排序**:

1. **功能正确性** - 确保核心功能(登录、搜索、下载、安装)正常工作
2. **平台兼容性** - 确保 iOS 和 macOS 平台都能正常运行
3. **用户体验** - 优化界面响应和错误提示
4. **性能优化** - 优化下载速度和内存使用
5. **代码质量** - 重构和优化代码结构

### 2. 代码优化阶段执行规范

**优化流程**:

1. **识别问题**: 使用 `codebase-retrieval` 查找相关代码
2. **分析根因**: 理解问题的根本原因
3. **设计方案**: 提出符合架构的优化方案
4. **实施优化**: 执行代码修改
5. **验证效果**: 建议编写测试验证优化效果

### 3. 优化原则与代码质量要求

**优化原则**:

- **最小改动**: 优先选择影响范围最小的方案
- **向后兼容**: 保持与现有 API 的兼容性
- **可测试性**: 确保修改后的代码易于测试
- **可维护性**: 代码应清晰、简洁、易于理解

**代码质量标准**:

- 遵循 Swift API 设计指南
- 保持一致的代码风格
- 添加必要的注释说明复杂逻辑
- 避免过度工程化

### 4. 问题解决到代码优化的完整流程

**完整流程示例**:

```
用户报告问题
    ↓
收集信息(codebase-retrieval, view)
    ↓
复述问题并确认理解
    ↓
分析影响范围和依赖
    ↓
设计解决方案
    ↓
列出需要修改的文件
    ↓
按顺序执行修改(Foundation -> Backend -> Interface)
    ↓
建议测试方案
    ↓
根据反馈进行优化
```

---

## 文档与注释

### 1. 代码注释规范

- **文件头注释**: 保持现有的文件头格式(包含文件名、项目名、作者、日期)
- **复杂逻辑**: 为复杂的算法和业务逻辑添加注释
- **公共 API**: 为公共接口添加文档注释
- **TODO/FIXME**: 使用标准标记标注待办事项

### 2. 修改说明格式

当进行代码修改时,向用户说明:

- **修改文件**: 列出所有修改的文件
- **修改内容**: 简要说明每个文件的修改内容
- **修改原因**: 解释为什么需要这样修改
- **影响范围**: 说明修改可能影响的功能
- **测试建议**: 建议如何测试修改

---

## 项目特定规则

### 1. ApplePackage 库

- `ApplePackage` 是独立的 Swift Package,位于 `Foundation/ApplePackage`
- 提供 Apple 账户认证、应用搜索、下载等核心功能
- 修改时需要同时考虑命令行工具和库的使用场景

### 2. 多平台支持

- 使用 `#if os(macOS)` 和 `#if canImport(UIKit)` 进行平台隔离
- `DeviceCTL` 功能仅在 macOS 上可用
- UI 组件需要适配 iOS 和 macOS 的不同交互模式

### 3. 状态持久化

- 使用 `@PublishedPersist` 属性包装器进行状态持久化
- 敏感数据存储在 Keychain: `wiki.qaq.Asspp.Accounts`, `wiki.qaq.Asspp.DeviceIdentifier`
- 普通数据使用 UserDefaults

### 4. 网络与安装

- 安装服务使用 Vapor 框架,监听随机端口(4000-8000)
- SNI 配置为 `app.localhost.qaq.wiki`
- 支持 HTTP 和 HTTPS(TLS)两种模式

---

## 总结

本规则文件基于 Asspp 项目的实际架构和代码风格生成,旨在指导 AI 助手:

1. 深入理解项目结构和业务逻辑
2. 遵循项目的代码风格和架构模式
3. 在修改代码时考虑全局影响
4. 提供高质量、可维护的代码
5. 确保多平台兼容性和安全性

**记住**: 始终优先使用 `codebase-retrieval` 和 `view` 工具收集信息,在充分理解的基础上进行修改。

